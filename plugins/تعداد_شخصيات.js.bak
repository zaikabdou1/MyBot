const fs = require("fs");
const path = require("path");
const challenges = require("./challenges.js"); // Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù…Ù„Ù Ø§Ù„Ø£Ø³Ø¦Ù„Ø©

const pointsFile = path.join(__dirname, "../data/ranks.json");
let points = {};
if (fs.existsSync(pointsFile)) points = JSON.parse(fs.readFileSync(pointsFile));
function savePoints() { fs.writeFileSync(pointsFile, JSON.stringify(points, null, 2)); }

function formatK(num) {
  if (num >= 1_000_000) return (num / 1_000_000).toFixed(1) + "M";
  if (num >= 1_000) return (num / 1_000).toFixed(1) + "K";
  return num.toString();
}

// Ù…Ù‚Ø§Ø±Ù†Ø© Ø¬Ø²Ø¦ÙŠØ©
function isAnswerCorrect(answer, correctAnswer) {
  return correctAnswer.includes(answer) || answer.includes(correctAnswer);
}

// ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø­Ø³Ø¨ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© (3 Ù…Ù† Ø£ØµÙ„ 6)
function checkAnswer(message, answers) {
  const words = message.replace(/\n/g, " ").replace(/[.,]/g, " ").trim().split(/\s+/);
  let count = 0;
  for (let ans of answers) {
    if (words.some(w => isAnswerCorrect(w, ans))) count++;
    if (count >= 3) break;
  }
  return count >= 3;
}

module.exports = {
  command: "ØªØ¹Ø¯Ø§Ø¯",
  category: "game",
  description: "Ù„Ø¹Ø¨Ø© ØªØ¹Ø¯Ø§Ø¯ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª",

  async execute(sock, msg) {
    const chatId = msg.key.remoteJid;
    if (!chatId.endsWith("@g.us")) return sock.sendMessage(chatId, { text: "âŒ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙŠØ¹Ù…Ù„ ÙÙ‚Ø· ÙÙŠ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª." }, { quoted: msg });

    // Ø§Ø®ØªÙŠØ§Ø± Ø³Ø¤Ø§Ù„ Ø¹Ø´ÙˆØ§Ø¦ÙŠ Ù…Ù† Ù…Ù„Ù challenges.js
    const challenge = challenges[Math.floor(Math.random() * challenges.length)];
    await sock.sendMessage(chatId, { text: `ğŸ® ØªØ­Ø¯ÙŠ Ø¬Ø¯ÙŠØ¯!\n${challenge.question}\nğŸ•’ Ø¹Ù†Ø¯Ùƒ 30 Ø«Ø§Ù†ÙŠØ©.` }, { quoted: msg });

    const filter = (m) => {
      if (m.key.remoteJid !== chatId || !m.message?.conversation) return false;
      return checkAnswer(m.message.conversation, challenge.answers);
    };

    const onMessage = async ({ messages }) => {
      const correct = messages.find(filter);
      if (!correct) return;

      const sender = correct.key.participant || correct.key.remoteJid;

      // Ø­Ø³Ø§Ø¨ Ø¹Ø¯Ø¯ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø§Øª Ø§Ù„ØµØ­ÙŠØ­Ø© Ù…Ù† Ø£ØµÙ„ 3 Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„
      const text = correct.message.conversation;
      let correctCount = 0;
      for (let ans of challenge.answers) {
        if (text.split(/\s+/).some(w => isAnswerCorrect(w, ans))) correctCount++;
        if (correctCount >= 3) break;
      }

      const pointsGained = 500 * correctCount;
      if (!points[sender]) points[sender] = 0;
      points[sender] += pointsGained;
      savePoints();

      await sock.sendMessage(chatId, {
        text: `âœ… Ø¥Ø¬Ø§Ø¨Ø© ØµØ­ÙŠØ­Ø©! ğŸ‰\nğŸ† Ø±ØµÙŠØ¯Ùƒ Ø§Ù„Ø¢Ù†: *${formatK(points[sender])}* Ù†Ù‚Ø·Ø©.`,
      }, { quoted: correct });
    };

    sock.ev.on("messages.upsert", onMessage);

    setTimeout(async () => {
      sock.ev.off("messages.upsert", onMessage);
      await sock.sendMessage(chatId, { text: `â° Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„ÙˆÙ‚Øª!` }, { quoted: msg });
    }, 30000);
  }
};